(defun make-sieve (n)
  (make-array n :initial-element t))

(defun simple-sieve (n)
  (let ((sieve (make-sieve (+ n 1))))
    (dotimes (i 2)
      (setf (aref sieve i) nil))
    (do ((i 2 (+ i 1)))
        ((> i n) nil)
      (do ((j (* i i) (+ j i)))
          ((> j n) nil)
        (setf (aref sieve j) nil)))
    sieve))

(defun sieve-to-primes (sieve)
  (let ((primes nil))
    (dotimes (n (length sieve) (reverse primes))
      (cond ((aref sieve n) (push n primes))))))

(defun segmented-sieve (n)
  (let ((m (+ (floor (sqrt n)) 1)))
    (let ((base-primes (prime-list m)))
      (setf m (incf m 1))
      (do ((i m (+ i m))
	   (sieve (make-sieve m) (make-sieve m))
	   (primes base-primes
		   (append primes
		    (mapcar #'(lambda (n) (+ n i)) (sieve-to-primes sieve)))))
	  ((> i n) primes)
	  (dolist (p base-primes)
	    (let ((x (* (floor (/ i p)) p)))
	      (let ((lo (if (< x i) (+ x p) x)))
		(do ((j lo (+ j p)))
		    ((>= j (+ i m)))
		    (setf (aref sieve (- j i)) nil)))))
	  (do ((j (+ n 1) (+ j 1)))
	      ((>= j (+ i m)))
	      (setf (aref sieve (- j i)) nil))))))

(defun print-primes (n)
  (let ((sieve (simple-sieve n)))
    (dotimes (i (+ n 1))
      (if (aref sieve i)
          (format t " ~d" i)))))

;;; conditionally augment primes list if ith element of sieve is true
(defun prime-list-aug  (vec i lis)
  (if (aref vec i)
      (cons i lis)
      lis))

(defun prime-list (n)
  (let ((sieve (simple-sieve n)))
    (do ((i 0 (+ i 1))
         (primes nil (prime-list-aug sieve i primes)))
        ((> i n) (reverse primes)))))
