(defun make-sieve (n)
  (make-array n :initial-element t))

(defun simple-sieve (n)
  (let ((sieve (make-sieve(+ n 1))))
    (dotimes (i 2)
      (setf (aref sieve i) nil))
    (do ((i 2 (+ i 1)))
	((> i (sqrt n)))
	(do ((j (* i i) (+ j i)))
	    ((> j n))
	    (setf (aref sieve j) nil)))
    sieve))

(defun print-primes (sieve)
  (dotimes (i (length sieve))
    (cond ((aref sieve i)
	   (format t " ~d" i)))))

(defun prime-list-aug (idx sieve lis)
  (if (aref sieve idx)
      (cons idx lis)
    lis))

(defun prime-list (n)
  (let ((sieve (simple-sieve n)))
    (do ((i n (- i 1))
	 (lis nil (prime-list-aug i sieve lis)))
	((zerop i) lis))))

(defun starting-p (lo p)
  (let ((res (* (floor lo p) p)))
    (if (< res lo)
	(+ res p)
      res)))

(defun compute-segment (p-list lo hi)
  (let ((segment (make-sieve (- hi lo))))
    (dolist (p p-list)
      (let ((np (starting-p lo p)))
	(do ((i np (+ i p)))
	    ((>= i hi) segment)
	    (setf (aref segment (- i lo)) nil))))
    segment))

;;; return list of primes found in segment
(defun seg-p (lo hi seg)
  (do ((i (- hi 1) (- i 1))
       (res nil (if (aref seg (- i lo)) (cons i res) res)))
      ((< i lo) res)))
      
;;; cons primes found in segment
(defun segmented-sieve-aux (lo hi seg lis)
  (do ((i lo (+ i 1))
       (res lis (if (aref seg (- i lo)) (cons i res) res)))
      ((>= i hi) res)))
      
(defun segmented-sieve (n)
  (let ((ssiz (+ (floor (sqrt n)) 2)))
    (let ((p-list (nreverse (prime-list (- ssiz 1)))))
      (do* ((lo ssiz (+ lo ssiz))
	    (hi (+ lo ssiz) (min (+ n 1) (+ hi ssiz)))
	    (segment (compute-segment p-list lo hi)
		     (compute-segment p-list lo hi))
            (res (segmented-sieve-aux lo hi segment p-list)
		 (segmented-sieve-aux lo hi segment res)))
	   ((> hi n) (nreverse res))))))
